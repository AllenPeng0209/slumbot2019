Build a new heads-up system:
1) Will use base for preflop and flop; resolve turn and river
2) Therefore null abstraction preflop and flop
3) Therefore rich betting abstraction preflop and flop w/ one bet and raise turn and river
4) Asymmetric betting abstraction with only one bet size for us
5) Boosting?
6) Reentrant on turn and river?
7) Quantize on turn and river, at least.
8) Don't save sumprobs for turn or river

head_to_head now giving results for asymmetric, but I'm not sure if I believe them or not.
Really big win for symmetric mb1b2 against asymmetric asyma.  OTOH, much smaller win
for symmetric mb1b1aai against asymb.  Which I expect because all-ins should be less
useful.

Could try asymmetric system that doesn't give extra options to the opponent?  That's what
testasym did.  That still doesn't prove things are fully working.  There could be a problem
aligning succs, for example.  The test with mb1b1aai and asymb was better and gave a much
smaller advantage to the symmetric player.  Is that conclusive?  Might be nice to have
a made up bet size that is in the middle of valid bet sizes but which always leads to a
terrible outcome for the bettor.  In that case the symmetric and asymmetric players should
perform identically.

Should we even save opponent sumprobs in asymmetric system?

Evaluate char quantization for flop, turn and river.

Evaluate boosting on game with many betting sequences (mb2b2aai).

Do I want to just use symmetric training so that I don't need to worry about what bet sizes
are most important?

Incorporate combined endgame solving into head_to_head; see how well it works.

Experiment with combination of:
1) TCFR
2) holdem
3) kmeans abstraction; null for preflop/flop, 1000 buckets for turn/river
4) Quantize turn and river
5) Asymmetric betting abstraction (asymc)
6) Should I turn off saving of sumprobs for turn/river?  Try that later.

Try CFR+ with a hard warmup.

Can we resolve flops offline like Lars?  Solving flop subgame (mb1b1) taking 7m10s.
6 resolves is 44m, but we will want to use a richer preflop abstraction than mb1b1.
Call it 1 hour.  1755 flops is 1755 thread-hours.  With 8 threads, 220 hours.  About 9
days.  Doable.  On Amazon would be faster.  But if we want a richer preflop or flop betting
abstraction, that's going to make a big difference.

Could make head_to_head twice as fast with unsafe endgame solving.  Solving each subgame twice
now and we don't need to.

head_to_head may repeatedly solve flop or turn subgames.  Should figure out the minimal set
we need to resolve.  Also: if we're going to solve a flop subgame, should we just go ahead
and evaluate every river board consistent with that flop?

Measure speed of turn resolving.  One bet size and one raise size for turn and river.
Add multithreading?  VCFR already supports spinning off threads.  Need to allow control of
what street to split on.

Switch to mb2b2ai as testbed.  May need more actions for tcfr to outperform ecfr.  May need
more actions for boosting to help resolving.  May need more actions for combined resolved systems
to outperform unsafe resolved systems.

Create resolve params, use for things like head_to_head and solve_all_subgames.  Should help
reduce length of command lines.

Experiment with MCTS as a tool for approximate best-response calculations.

Support progressive endgame resolving.  Including resolves rooted at street initial nodes.

Experiment with multiplayer and reentrancy.  Evaluate with head-to-head?  Can we use h5;
i.e., a 20 card deck?  6 hole cards, 5 board cards, 9 unused cards.  I guess so.

Support multiplayer in endgame solving.  Need to support multiplayer betting trees in
CreateSubtree() in solve_all_subgames.

Build a h5ms3f1p6 system with a non-reentrant tree.  Currently using hs3 buckets, but should
probably do something better for the river, and bucket the turn as well.

Finish converting unsigned ints to ints everywhere.

Get rid of cast to float of cbr values in dynamic_cbr.cpp.

Should I boost CVs instead of boosting regrets?  Can I boost only at leaf nodes?  I don't want
to boost at several nonterminals on the way to a river terminal node, do I?  Wouldn't that lead
to too much boosting?

Boosting at terminal nodes is possibly excessive.  I only want to force players to reach every
nonterminal.  But maybe it wouldn't hurt too much to do so.

For deeply embedded nodes, I am worried about the boosting becoming very attenuated.  Only
1/1000 hands may go down the preflop succ.  Then maybe only 1/1000 down a flop succ.  By the
logic of Targeted CFR, can we do iterations that are forced to go down the boosted succs?

Use newer FileReader and FileWriter classes in slumbot2019

Can we clean up templated code.  Or abandon that approach even?  OppChoice() is a bit of a
mess.  Try to clean that up if nothing else.  Would it help to make VCFR templated?

Incorporate more modern C++:
1) Replace new with unique_ptr everywhere possible
2) Look into std::array and other container we might want to use
3) Use auto wherever possible; e.g., for iterators
4) Use modern C++ multithreading capabilities
5) Use modern C++ mutex capabilities
6) Isn't there a new kind of iteration?
7) Use modern C++ braced initialization
8) Get rid of typedefs.  Used aliases.
9) Use scoped enums.
10) CFRValues should not take pointer to betting tree
11) Replace NULL with nullptr everywhere possible

Fix determ play

It's a mess that we need to pass around root_bd_st/root_bd and if we get it wrong there are subtle
errors.

Is there a discrepancy with suited vs. unsuited hands in TCFR?  Can get very different strategies.

Multithread play and/or play_resolved

Can we get rid of two ways of hole card pair indexing?

Understand why we lost so badly to ackr.  Preflop purification?
